/* 테이블 생성 
 * 1. 직원정보 OK PL/SQL
 * 2. 부서정보 OK PL/SQL
 * 2-1. 부서이동정보 OK INSERT SELECT
 * 3. 연봉정보 OK PL/SQL
 * 3-1. 연봉이력정보 OK INSERT SELECT
 * 4. 지급내역정보 PL/SQL
 * 5. 근태정보 
 */
 
/* 1. 직원정보 */
CREATE TABLE EMPLOYEE(
    EM_CODE     NUMBER(5)       NOT NULL, -- 사원코드
    EM_NAME     VARCHAR2(20)            ,
    DE_CODE     NUMBER(5)               ,
    SA_RANK     VARCHAR2(2)             ,
    EM_DATE     VARCHAR2(8)             ,
    EM_TEL      VARCHAR2(13)            ,
    EM_ADDR     VARCHAR2(50)            ,
    EM_JOIN     VARCHAR2(8)             ,
    EM_QUIT     VARCHAR2(8)             ,
    CONSTRAINT EMPLOYEE_PK PRIMARY KEY (EM_CODE)
);


/* 2. 부서정보 */
CREATE TABLE DEOARTMENT(
    DE_CODE     NUMBER(5)      NOT NULL, -- 부서코드
    DE_NAME     VARCHAR2(20)           ,  -- 부서이름
    CONSTRAINT DEOARTMENT_PK PRIMARY KEY (DE_CODE)
);


/* 2-1. 부서이동정보 */ 
CREATE TABLE MOVEDEOARTMENT(
    EM_CODE     NUMBER(5)       NOT NULL,
    BF_MD_CODE  NUMBER(5)       NOT NULL,
    AF_MD_CODE  NUMBER(5)               ,
    MD_DATE     VARCHAR2(8)                    
);

ALTER TABLE MOVEDEOARTMENT ADD CONSTRAINT MOVEDEOARTMENT_PK PRIMARY KEY (EM_CODE, BF_MD_CODE, AF_MD_CODE);


/* 3. 연봉테이블 */
CREATE TABLE SALARY(
    SA_CODE     NUMBER(5)       NOT NULL, 
    SA_YEAR     VARCHAR2(4)     NOT NULL,
    DE_CODE     NUMBER(5)       NOT NULL,
    SA_RANK     VARCHAR2(2)     NOT NULL,
    SA_AMT      NUMBER(10)      NOT NULL
);

ALTER TABLE SALARY ADD CONSTRAINT SALARY_PK PRIMARY KEY (SA_CODE, SA_YEAR, DE_CODE, SA_RANK);


/* 3-1. 연봉이력정보 */ 
CREATE TABLE SALARYHISTORY(
    EM_CODE     NUMBER(5)       NOT NULL,
    SA_CODE     NUMBER(5)       NOT NULL,
    SH_DATE     VARCHAR2(8)                    
);

ALTER TABLE SALARYHISTORY ADD CONSTRAINT SALARYHISTORY_PK PRIMARY KEY (EM_CODE, SA_CODE);

/* 4. 지급내역정보(급여 퇴직금) */ 
CREATE TABLE PAYROLL(
    EM_CODE     NUMBER(5)       NOT NULL,
    PA_CODE     VARCHAR2(2)     NOT NULL,
    PA_ATDATE   VARCHAR2(8)             ,
    PA_PAYDATE  VARCHAR2(10)        DEFAULT SYSDATE,
    PA_NORMAL   NUMBER(10)      NOT NULL,
    PA_MEAL     NUMBER(10)              ,
    PA_DRIVE    NUMBER(10)              ,
    PA_BONUS    NUMBER(10)              ,
    PA_OVER     NUMBER(10)              ,
    PA_ETC      NUMBER(10)              ,
    PA_HEALTH   NUMBER(10)              ,
    PA_LONGCARE NUMBER(10)              ,
    PA_NOTIONAL NUMBER(10)              ,
    PA_EMP      NUMBER(10)              ,
    PA_PAYETC   NUMBER(10)              ,
    PA_TAX      NUMBER(10)              ,
    PA_LOCALTAX NUMBER(10)              
);

ALTER TABLE PAYROLL ADD CONSTRAINT PAYROLL_PK PRIMARY KEY (EM_CODE, PA_CODE, PA_ATDATE, PA_PAYDATE, PA_NORMAL );


/* 5. 근태정보 */ 
CREATE TABLE ATTENDANCE(
    EM_CODE     NUMBER(5)       NOT NULL,
    AT_CODE     NUMBER(5)       NOT NULL,
    AT_DATE     VARCHAR2(8)             ,
    CONSTRAINT ATTENDANCE_PK PRIMARY KEY (EM_CODE, AT_CODE, AT_DATE)
);


COMMIT;


/* 전체 테이블 조회*/
SELECT * FROM USER_ALL_TABLES;

SELECT * FROM EMPLOYEE;
SELECT * FROM DEOARTMENT;
SELECT * FROM MOVEDEOARTMENT;
SELECT * FROM SALARY;
SELECT * FROM SALARYHISTORY;
SELECT * FROM PAYROLL;
SELECT * FROM ATTENDANCE;



---- PL/SQL LOOP, FOR문 ----
/* 부서정보 */
DECLARE
 DE_NAME VARCHAR2(100) := 'test1_';
BEGIN
	 FOR i IN 1..10
	 LOOP
	 INSERT INTO DEOARTMENT
	 VALUES
	 (i, 
      DE_NAME || i
      );
	END LOOP;
    COMMIT;
END;


/* 직원정보 */

DECLARE
 EM_NAME VARCHAR2(100) := 'test6_';
 SA_RANK VARCHAR2(2) := 'D'; 
 EM_DATE VARCHAR2(8) := '19990101';
BEGIN
	 FOR i IN 231..250
	 LOOP
	 INSERT INTO EMPLOYEE
	 VALUES
	 (i, 
      EM_NAME || i,
      i,
      SA_RANK,
      EM_DATE,
      NULL,
      NULL,
      '20171001',
      NULL
      );
	END LOOP;
    COMMIT;
END;


/* 지급내역정보 - 수동날짜 */

BEGIN
	 FOR i IN 51..250
	 LOOP
	 INSERT INTO PAYROLL
	 VALUES
	 (i, 
      'S',
      '2023-08',
      '9999-99-99',
      (SELECT ROUND(SA_AMT / 12, 0) FROM SALARY WHERE SA_YEAR = '2023' AND SA_RANK = (SELECT SA_RANK FROM EMPLOYEE WHERE EM_CODE = i)),
      200000,
      200000,
      (SELECT ROUND(SA_AMT / 12, 0) * 0.5 FROM SALARY WHERE SA_YEAR = '2023' AND SA_RANK = (SELECT SA_RANK FROM EMPLOYEE WHERE EM_CODE = i)),
      NULL,
      NULL,
      NULL, 
      NULL, 
      NULL, 
      NULL,
      NULL,
      NULL,
      NULL
      );
	END LOOP;
    COMMIT;
END;


/* 연봉정보 */

INSERT INTO SALARY VALUES(1, '2017', 1, 'A', 12000000);
INSERT INTO SALARY VALUES(2, '2017', 2, 'B', 15000000);
INSERT INTO SALARY VALUES(3, '2017', 3, 'C', 20000000);
INSERT INTO SALARY VALUES(4, '2017', 4, 'D', 25000000);
INSERT INTO SALARY VALUES(5, '2017', 5, 'E', 40000000);

INSERT INTO SALARY VALUES(1, '2018', 1, 'A', 12000000);
INSERT INTO SALARY VALUES(2, '2018', 2, 'B', 15000000);
INSERT INTO SALARY VALUES(3, '2018', 3, 'C', 20000000);
INSERT INTO SALARY VALUES(4, '2018', 4, 'D', 25000000);
INSERT INTO SALARY VALUES(5, '2018', 5, 'E', 40000000);

INSERT INTO SALARY VALUES(1, '2019', 1, 'A', 20000000);
INSERT INTO SALARY VALUES(2, '2019', 2, 'B', 25000000);
INSERT INTO SALARY VALUES(3, '2019', 3, 'C', 30000000);
INSERT INTO SALARY VALUES(4, '2019', 4, 'D', 35000000);
INSERT INTO SALARY VALUES(5, '2019', 5, 'E', 60000000);

INSERT INTO SALARY VALUES(1, '2020', 1, 'A', 30000000);
INSERT INTO SALARY VALUES(2, '2020', 2, 'B', 35000000);
INSERT INTO SALARY VALUES(3, '2020', 3, 'C', 40000000);
INSERT INTO SALARY VALUES(4, '2020', 4, 'D', 45000000);
INSERT INTO SALARY VALUES(5, '2020', 5, 'E', 80000000);

INSERT INTO SALARY VALUES(1, '2021', 1, 'A', 31000000);
INSERT INTO SALARY VALUES(2, '2021', 2, 'B', 36000000);
INSERT INTO SALARY VALUES(3, '2021', 3, 'C', 41000000);
INSERT INTO SALARY VALUES(4, '2021', 4, 'D', 46000000);
INSERT INTO SALARY VALUES(5, '2021', 5, 'E', 85000000);

INSERT INTO SALARY VALUES(1, '2022', 1, 'A', 33000000);
INSERT INTO SALARY VALUES(2, '2022', 2, 'B', 38000000);
INSERT INTO SALARY VALUES(3, '2022', 3, 'C', 43000000);
INSERT INTO SALARY VALUES(4, '2022', 4, 'D', 48000000);
INSERT INTO SALARY VALUES(5, '2022', 5, 'E', 89000000);

INSERT INTO SALARY VALUES(1, '2023', 1, 'A', 35000000);
INSERT INTO SALARY VALUES(2, '2023', 2, 'B', 40000000);
INSERT INTO SALARY VALUES(3, '2023', 3, 'C', 45000000);
INSERT INTO SALARY VALUES(4, '2023', 4, 'D', 50000000);
INSERT INTO SALARY VALUES(5, '2023', 5, 'E', 105000000);


/* 4대보험 UPDATE*/

MERGE
INTO PAYROLL B
USING (
    SELECT EM_CODE, 
            PA_ATDATE, 
            ROUND((A.PA_NORMAL + A.PA_BONUS) * 0.0306, -1) AS HEALTH,
            ROUND((A.PA_NORMAL + A.PA_BONUS) * 0.0306 * 0.0655, -1) AS LONGS,
            ROUND((A.PA_NORMAL + A.PA_BONUS) * 0.045, -1) AS NOTION,
            ROUND((A.PA_NORMAL + A.PA_BONUS) * 0.0065, -1) AS EMP
    FROM PAYROLL A
) A 
ON (
    A.EM_CODE = B.EM_CODE 
    AND A.PA_ATDATE = B.PA_ATDATE
    )
WHEN MATCHED THEN
UPDATE 
SET 
B.PA_HEALTH = A.HEALTH,
   B.PA_LONGCARE = A.LONGS,
   B.PA_NOTIONAL = A.NOTION,
  B.PA_EMP = A.EMP
;
    

/* 4대보험 계산 */

SELECT
		EM_CODE,
		PA_ATDATE,
		ROUND((PA_NORMAL + PA_BONUS) * 0.0306, -1) AS HEALTH,
		ROUND((PA_NORMAL + PA_BONUS) * 0.0306 * 0.0655, -1) AS LONGS,
		ROUND((PA_NORMAL + PA_BONUS) * 0.045, -1) AS NOTION,
		ROUND((PA_NORMAL + PA_BONUS) * 0.0065, -1) AS EMP
FROM
		PAYROLL;

	
/* 급여 실지급액 계산 */
	
SELECT  
        B.DE_CODE, 
        SUM(급여), 
        SUM(차감액),  
        SUM(실지급액)
FROM (
        SELECT EM_CODE,
                (PA_NORMAL+ PA_MEAL + PA_DRIVE + PA_BONUS) AS 급여, 
                (PA_HEALTH + PA_LONGCARE + PA_NOTIONAL + PA_EMP) AS 차감액,  
                (PA_NORMAL+ PA_MEAL + PA_DRIVE + PA_BONUS)-(PA_HEALTH + PA_LONGCARE + PA_NOTIONAL + PA_EMP) AS 실지급액
        FROM PAYROLL
) A, EMPLOYEE B
WHERE A.EM_CODE = B.EM_CODE
GROUP BY DE_CODE;


/* 연봉테이블 수정 및 연봉이력 변경 및 월급 지급일 수정 */

UPDATE PAYROLL
 SET PA_PAYDATE = '2023-08-10'
WHERE PA_ATDATE = '2023-07';

SELECT REPLACE(PA_PAYDATE, '-') FROM PAYROLL;

UPDATE PAYROLL SET PA_PAYDATE = REPLACE(PA_PAYDATE, '-'), PA_ATDATE =  REPLACE(PA_ATDATE, '-');


SELECT * FROM EMPLOYEE;
SELECT * FROM DEOARTMENT;
SELECT * FROM MOVEDEOARTMENT;

MERGE
INTO PAYROLL B
USING (
    SELECT EM_CODE, 
            PA_ATDATE, 
            ROUND((A.PA_NORMAL + A.PA_BONUS) * 0.0306, -1) AS HEALTH,
            ROUND((A.PA_NORMAL + A.PA_BONUS) * 0.0306 * 0.0655, -1) AS LONGS,
            ROUND((A.PA_NORMAL + A.PA_BONUS) * 0.045, -1) AS NOTION,
            ROUND((A.PA_NORMAL + A.PA_BONUS) * 0.0065, -1) AS EMP
    FROM PAYROLL A
) A 
ON (
    A.EM_CODE = B.EM_CODE 
    AND A.PA_ATDATE = B.PA_ATDATE
    )
WHEN MATCHED THEN
UPDATE 
SET 
B.PA_HEALTH = A.HEALTH,
   B.PA_LONGCARE = A.LONGS,
   B.PA_NOTIONAL = A.NOTION,
  B.PA_EMP = A.EMP
 ;


/* 기본부서정보 INSERT */

INSERT INTO MOVEDEOARTMENT C
SELECT
		B.EM_CODE,
		NVL(A.AF_MD_CODE, B.DE_CODE),
		B.DE_CODE,
		EM_JOIN
FROM
		MOVEDEOARTMENT A
RIGHT OUTER JOIN 	EMPLOYEE B 
ON
		A.EM_CODE = B.EM_CODE AND A.AF_MD_CODE != B.DE_CODE ;


/* 직원 정보 변경 후 부서이동 INSERT */
	
INSERT INTO MOVEDEOARTMENT C
SELECT
		B.EM_CODE,
		NVL(A.AF_MD_CODE, B.DE_CODE),
		B.DE_CODE,
		TO_CHAR(SYSDATE, 'YYYYMMDD') AS MD_DATE
FROM
		MOVEDEOARTMENT A
JOIN 	EMPLOYEE B 
ON
		A.EM_CODE = B.EM_CODE AND A.AF_MD_CODE != B.DE_CODE ;
	
	
/* 연봉이력정보 */

SELECT * FROM SALARY;
SELECT * FROM SALARYHISTORY;

INSERT INTO SALARYHISTORY 
SELECT A.EM_CODE, B.SA_CODE, B.SA_YEAR || '0101' AS SH_DATE
FROM EMPLOYEE A JOIN SALARY B ON A.SA_RANK = B.SA_RANK AND A.DE_CODE = B.DE_CODE
ORDER BY SH_DATE 
;


/* 연차 + 결근 */

SELECT * FROM ATTENDANCE; -- AT_CODE = 1 결근 / 2 연차


WITH 
B AS ( -- 결근
			SELECT
							A.EM_CODE,
							TO_DATE(SUBSTR(AT_DATE, 1, 6), 'YYYY-MM') ,
							CASE WHEN COUNT(1) > 1 
							     THEN 1
							     ELSE COUNT(1)
							END AS COUNT
			FROM
							ATTENDANCE A
			JOIN EMPLOYEE B ON
				A.EM_CODE = B.EM_CODE
			WHERE
							AT_CODE = 1
				AND AT_DATE BETWEEN TO_DATE(B.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '0' YEAR) AND TO_DATE(B.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '1' YEAR)
			GROUP BY
							A.EM_CODE, TO_DATE(SUBSTR(AT_DATE, 1, 6), 'YYYY-MM')
	      ),
C AS ( -- 연차 사용
			SELECT
							A.EM_CODE,
							COUNT(1) AS COUNT
			FROM
							ATTENDANCE A
			JOIN EMPLOYEE B ON
				A.EM_CODE = B.EM_CODE
			WHERE
							AT_CODE = 2
				AND AT_DATE BETWEEN TO_DATE(B.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '0' YEAR) AND TO_DATE(B.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '1' YEAR)
			GROUP BY
							A.EM_CODE
	      )
SELECT
		A.EM_CODE
		,ROUND(((TO_DATE(A.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '1' YEAR)) - TO_DATE(A.EM_JOIN, 'YYYYMMDD') + 1) / 30) - 1 AS "2017_발생 예상 연차"
		,ROUND(((TO_DATE(A.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '1' YEAR)) - TO_DATE(A.EM_JOIN, 'YYYYMMDD') + 1) / 30) - 1 - NVL(SUM(B.COUNT), 0) AS "발생연차"
		,NVL(SUM(B.COUNT), 0) AS "결근"
		,C.COUNT AS "연차사용"
		,ROUND(((TO_DATE(A.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '1' YEAR)) - TO_DATE(A.EM_JOIN, 'YYYYMMDD') + 1) / 30) - 1 - NVL(SUM(B.COUNT), 0) - C.COUNT AS "잔여연차"
FROM
		EMPLOYEE A
RIGHT JOIN B ON
		A.EM_CODE = B.EM_CODE
RIGHT JOIN C ON
		A.EM_CODE = C.EM_CODE
WHERE A.EM_CODE = 1
GROUP BY
		A.EM_CODE, A.EM_JOIN, C.COUNT
;


/* 연차 최대갯수
 * 입사 : 1개월 만근시 1개씩 최대 11개
 * 입사 1-2년 : 15개
 * 입사 3-4년 : 16개
 * 입사 5-6년 : 17개
 * 입사 7-8년 : 18개
 * 입사 9-14년 : 19개
 * 입사 15-18년 : 22개
 * 입사 19-20년 : 24개
 * 입사 21-24년 : 25개
 * 입사 25년 이후 25개
 * */

/* 입사년차 및 연차갯수 */
SELECT TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) AS "입사_후_몇년",
	   TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365),
	   CASE WHEN TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) = 0 -- 경우1 : 입사 : 1개월 만근시 1개씩 최대 11개
	        THEN TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 30 - 1) 
	        WHEN TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) <= 2 
	        	AND TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) < 3 -- 경우2 : 입사 1-2년 : 15개
	        THEN 15
	        WHEN TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) <= 4 
	        	AND TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) < 5 -- 경우3 : 입사 3-4년 : 16개
	        THEN 16
	        WHEN TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) <= 6 
	        	AND TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) < 7 -- 경우4 : 입사 5-6년 : 17개
	        THEN 17
	        WHEN TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) <= 8 
	        	AND TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) < 9 -- 경우5 : 입사 7-8년 : 18개
	        THEN 18
	        WHEN TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) <= 14
	        	AND TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) < 15 -- 경우6 : 입사 9-14년 : 19개
	        THEN 19
	        WHEN TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) <= 18 
	        	AND TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) < 19 -- 경우7 : 입사 15-18년 : 22개
	        THEN 22
	        WHEN TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) <= 20
	        	AND TRUNC(TRUNC(SYSDATE - TO_DATE(:AT_DATE, 'YYYY-MM-DD'), 1) / 365) < 21 -- 경우8 : 입사 19-20년 : 24개
	        THEN 24
			ELSE 25
		END AS "연차발생일수"
FROM DUAL;


/* 연차*/
WITH 
B AS ( -- 결근
			SELECT
							A.EM_CODE,
							TO_DATE(SUBSTR(AT_DATE, 1, 6), 'YYYY-MM') ,
							CASE WHEN COUNT(1) > 1 
							     THEN 1
							     ELSE COUNT(1)
							END AS COUNT
			FROM
							ATTENDANCE A
			JOIN EMPLOYEE B ON
				A.EM_CODE = B.EM_CODE
			WHERE
							AT_CODE = 1
				AND AT_DATE BETWEEN TO_DATE(B.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '0' YEAR) -- 파라미터
							AND TO_DATE(B.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '1' YEAR) -- 파라미터
			GROUP BY
							A.EM_CODE, TO_DATE(SUBSTR(AT_DATE, 1, 6), 'YYYY-MM')
	      ),
C AS ( -- 연차 사용
			SELECT
							A.EM_CODE,
							COUNT(1) AS COUNT
			FROM
							ATTENDANCE A
			JOIN EMPLOYEE B ON
				A.EM_CODE = B.EM_CODE
			WHERE
							AT_CODE = 2
				AND AT_DATE BETWEEN TO_DATE(B.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '0' YEAR) -- 파라미터
							AND TO_DATE(B.EM_JOIN, 'YYYY-MM-DD') + (INTERVAL '1' YEAR) -- 파라미터
			GROUP BY
							A.EM_CODE
	      ),
D AS ( -- 년차
			SELECT
							EM_CODE,
							TRUNC(TRUNC(SYSDATE - TO_DATE(EM_JOIN, 'YYYY-MM-DD'), 1) / 365) AS YEARS
			FROM
							EMPLOYEE
	      )
SELECT
		A.EM_CODE,
		CASE
			WHEN D.YEARS = 0
		-- 경우1 : 입사 : 1개월 만근시 1개씩 최대 11개
			        THEN 11
		WHEN D.YEARS <= 2
		AND D.YEARS < 3
		-- 경우2 : 입사 1-2년 : 15개
			        THEN 15
		WHEN D.YEARS <= 4
		AND D.YEARS < 5
		-- 경우3 : 입사 3-4년 : 16개
			        THEN 16
		WHEN D.YEARS <= 6
		AND D.YEARS < 7
		-- 경우4 : 입사 5-6년 : 17개
			        THEN 17
		WHEN D.YEARS <= 8
		AND D.YEARS < 9
		-- 경우5 : 입사 7-8년 : 18개
			        THEN 18
		WHEN D.YEARS <= 14
		AND D.YEARS < 15
		-- 경우6 : 입사 9-14년 : 19개
			        THEN 19
		WHEN D.YEARS <= 18
		AND D.YEARS < 19
		-- 경우7 : 입사 15-18년 : 22개
			        THEN 22
		WHEN D.YEARS <= 20
		AND D.YEARS < 21
		-- 경우8 : 입사 19-20년 : 24개
			        THEN 24
		ELSE 25
	END AS "연차발생일수",
	SUM(NVL(B.COUNT, 0)) AS "결근",
	C.COUNT AS "연차사용"
FROM
		EMPLOYEE A
RIGHT OUTER JOIN B ON A.EM_CODE = B.EM_CODE
RIGHT OUTER JOIN C ON A.EM_CODE = C.EM_CODE
JOIN D ON A.EM_CODE = D.EM_CODE
WHERE
	A.EM_CODE = 2
GROUP BY
		A.EM_CODE, D.YEARS, C.COUNT
;







/* 연차 */
WITH 
B AS ( -- 결근
			SELECT
							A.EM_CODE,
							TO_DATE(SUBSTR(AT_DATE, 1, 6), 'YYYYMM') AS MONTHS,
							CASE WHEN COUNT(1) > 1 
							     THEN 1
							     ELSE COUNT(1)
							END AS COUNT
			FROM
							ATTENDANCE A
			JOIN EMPLOYEE B ON
				A.EM_CODE = B.EM_CODE
			WHERE
							AT_CODE = 1
			GROUP BY
							A.EM_CODE, TO_DATE(SUBSTR(AT_DATE, 1, 6), 'YYYYMM')
	      ),
C AS ( -- 연차 사용
			SELECT
							A.EM_CODE,
							TO_DATE(SUBSTR(AT_DATE, 1, 6), 'YYYYMM') AS MONTHS,
							COUNT(1) AS COUNT
			FROM
							ATTENDANCE A
			JOIN EMPLOYEE B ON
				A.EM_CODE = B.EM_CODE
			WHERE
							AT_CODE = 2
			GROUP BY
							A.EM_CODE, TO_DATE(SUBSTR(AT_DATE, 1, 6), 'YYYYMM')
	      ),
D AS ( -- 년차
			SELECT
							EM_CODE,
							TRUNC(TRUNC(SYSDATE - TO_DATE(EM_JOIN, 'YYYY-MM-DD'), 1) / 365) AS YEARS
			FROM
							EMPLOYEE
	      )
SELECT
		A.EM_CODE,
		CASE
			WHEN D.YEARS = 0
		-- 경우1 : 입사 : 1개월 만근시 1개씩 최대 11개
			        THEN 11
		WHEN D.YEARS <= 2
		AND D.YEARS < 3
		-- 경우2 : 입사 1-2년 : 15개
			        THEN 15
		WHEN D.YEARS <= 4
		AND D.YEARS < 5
		-- 경우3 : 입사 3-4년 : 16개
			        THEN 16
		WHEN D.YEARS <= 6
		AND D.YEARS < 7
		-- 경우4 : 입사 5-6년 : 17개
			        THEN 17
		WHEN D.YEARS <= 8
		AND D.YEARS < 9
		-- 경우5 : 입사 7-8년 : 18개
			        THEN 18
		WHEN D.YEARS <= 14
		AND D.YEARS < 15
		-- 경우6 : 입사 9-14년 : 19개
			        THEN 19
		WHEN D.YEARS <= 18
		AND D.YEARS < 19
		-- 경우7 : 입사 15-18년 : 22개
			        THEN 22
		WHEN D.YEARS <= 20
		AND D.YEARS < 21
		-- 경우8 : 입사 19-20년 : 24개
			        THEN 24
		ELSE 25
	END AS "연차발생일수",
	SUM(NVL(B.COUNT, 0)) AS "결근",
	NVL(C.COUNT, 0) AS "연차사용"
FROM
		EMPLOYEE A
RIGHT OUTER JOIN B ON A.EM_CODE = B.EM_CODE AND SUBSTR(TO_CHAR(B.MONTHS, 'YYYYMM'), 1, 4) = '2018'
RIGHT OUTER JOIN C ON A.EM_CODE = C.EM_CODE AND SUBSTR(TO_CHAR(C.MONTHS, 'YYYYMM'), 1, 4) = '2018'
JOIN D ON A.EM_CODE = D.EM_CODE
WHERE
	A.EM_CODE = 100
GROUP BY
		A.EM_CODE, D.YEARS, NVL(C.COUNT, 0)
;


/* 별도. 근무내역(주말포함) - 자동화 */ 

CREATE TABLE WORKHISTORY(
    EM_CODE     NUMBER(5)       NOT NULL,
    WH_DATE 	DATE             		,
    WH_STATUS	VARCHAR2(1)
);

ALTER TABLE WORKHISTORY ADD CONSTRAINT WORKHISTORY_PK PRIMARY KEY (EM_CODE, WH_DATE, WH_STATUS);
















-- 스케줄러 테스트를 위한 프로시저 생성
CREATE OR REPLACE PROCEDURE JOB_WORKHISTORY_IN
AS
BEGIN
    INSERT INTO WORKHISTORY
    SELECT EM_CODE, SYSDATE, '1'
      FROM EMPLOYEE A
     WHERE EM_QUIT IS NULL
       AND NOT EXISTS (SELECT 1
                         FROM ATTENDANCE B
                        WHERE A.EM_CODE = B.EM_CODE
                          AND TO_CHAR(SYSDATE, 'YYYYMMDD') = B.AT_DATE
                      );
                     
    INSERT INTO JOB_AUTOMATION
    SELECT (SELECT MAX(JA_CODE) + 1 FROM JOB_AUTOMATION), 'JOB_WORKHISTORY_OUT', SYSDATE, COUNT(1)
      FROM WORKHISTORY
     WHERE TO_CHAR(WH_DATE,'YYYYMMDDHH24MI') = TO_CHAR(SYSDATE,'YYYYMMDDHH24MI')
       AND WH_STATUS = '1';
       
    COMMIT;
END;


CREATE OR REPLACE PROCEDURE JOB_WORKHISTORY_OUT
AS
BEGIN
    INSERT INTO WORKHISTORY
    SELECT EM_CODE, SYSDATE, '-1'
      FROM EMPLOYEE A
     WHERE EM_QUIT IS NULL
       AND NOT EXISTS (SELECT 1
                         FROM ATTENDANCE B
                        WHERE A.EM_CODE = B.EM_CODE
                          AND TO_CHAR(SYSDATE, 'YYYYMMDD') = B.AT_DATE
                      );
                     
    INSERT INTO JOB_AUTOMATION
    SELECT (SELECT MAX(JA_CODE) + 1 FROM JOB_AUTOMATION), 'JOB_WORKHISTORY_OUT', SYSDATE, COUNT(1)
      FROM WORKHISTORY
     WHERE TO_CHAR(WH_DATE,'YYYYMMDDHH24MI') = TO_CHAR(SYSDATE,'YYYYMMDDHH24MI')
       AND WH_STATUS = '-1';
       
    COMMIT;
END;


CREATE OR REPLACE PROCEDURE JOB_PAYROLL_IN
AS
BEGIN
	INSERT INTO PAYROLL(
	EM_CODE
	,PA_CODE
	,PA_ATDATE
	,PA_PAYDATE
	,PA_NORMAL
	,PA_BONUS
	,PA_MEAL
	,PA_DRIVE
	,PA_OVER
	,PA_ETC
	,PA_HEALTH
	,PA_LONGCARE
	,PA_EMP
	,PA_NOTIONAL
	,PA_PAYETC
	,PA_LOCALTAX
	,PA_TAX
	)
	SELECT
		A.EM_CODE,
		'S',
		(SELECT SUBSTR(MAX(PA_PAYDATE),1,6) FROM PAYROLL WHERE EM_CODE = A.EM_CODE),
		SUBSTR(TO_CHAR(SYSDATE, 'YYYYMMDD'), 1, 8),
		ROUND((B.SA_AMT / 12), 0),
		100000,
		200000,
		200000,
		0,
		0,
		ROUND(ROUND((B.SA_AMT / 12), 0) * 0.03545, -1),
		ROUND((ROUND(ROUND((B.SA_AMT / 12), 0) * 0.03545, -1) * 0.06405), -1),
		ROUND(ROUND((B.SA_AMT / 12), 0) * 0.009, -1),
		ROUND(ROUND((B.SA_AMT / 12), 0) * 0.045, -1),
		0,
		0,
		0
	FROM
		EMPLOYEE A
	JOIN SALARY B ON
		A.DE_CODE = B.DE_CODE
		AND A.SA_RANK = B.SA_RANK
		AND B.SA_YEAR = TO_CHAR(SYSDATE, 'YYYY')
	WHERE
		A.EM_QUIT IS NULL;

                     
    INSERT INTO JOB_AUTOMATION
    SELECT (SELECT MAX(JA_CODE) + 1 FROM JOB_AUTOMATION), 'JOB_AUTOMATION', SYSDATE, COUNT(1)
      FROM SALARYHISTORY
     WHERE TO_CHAR(PA_PAYDATE,'YYYYMMDD') = TO_CHAR(SYSDATE,'YYYYMMDD');

    COMMIT;
END;


/*
INSERT INTO PAYROLL(
					EM_CODE
					,PA_CODE
					,PA_ATDATE
					,PA_PAYDATE
					,PA_NORMAL
					,PA_BONUS
					,PA_MEAL
					,PA_DRIVE
					,PA_OVER
					,PA_ETC
					,PA_HEALTH
					,PA_LONGCARE
					,PA_EMP
					,PA_NOTIONAL
					,PA_PAYETC
					,PA_LOCALTAX
					,PA_TAX
					)
SELECT
		A.EM_CODE,
		'S',
		(SELECT SUBSTR(MAX(PA_PAYDATE),1,6) FROM PAYROLL WHERE EM_CODE = A.EM_CODE),
		SUBSTR(TO_CHAR(SYSDATE, 'YYYYMMDD'), 1, 8),
		ROUND((B.SA_AMT / 12), 0),
		100000,
		200000,
		200000,
		0,
		0,
		ROUND(ROUND((B.SA_AMT / 12), 0) * 0.03545, -1),
		ROUND((ROUND(ROUND((B.SA_AMT / 12), 0) * 0.03545, -1) * 0.06405), -1),
		ROUND(ROUND((B.SA_AMT / 12), 0) * 0.009, -1),
		ROUND(ROUND((B.SA_AMT / 12), 0) * 0.045, -1),
		0,
		0,
		0
FROM
		EMPLOYEE A
JOIN SALARY B ON
		A.DE_CODE = B.DE_CODE
		AND A.SA_RANK = B.SA_RANK
		AND B.SA_YEAR = TO_CHAR(SYSDATE, 'YYYY')
WHERE
		A.EM_QUIT IS NULL;
*/




/* 별도. 근무내역(주말포함) - 자동화 */ 
CREATE TABLE WORKHISTORY(
    EM_CODE     NUMBER(5)       NOT NULL,
    WH_DATE 	DATE             		,
    WH_STATUS	VARCHAR2(1)
);

ALTER TABLE WORKHISTORY ADD CONSTRAINT WORKHISTORY_PK PRIMARY KEY (EM_CODE, WH_DATE, WH_STATUS);

SELECT * FROM WORKHISTORY;



CREATE TABLE JOB_AUTOMATION(
    JA_CODE     NUMBER(5)       NOT NULL,
    JA_NAME     VARCHAR2(50)    NOT NULL,
    JA_DATE     DATE			NOT NULL,
    JA_COUNT    NUMBER(5)	    NOT NULL
);

ALTER TABLE JOB_AUTOMATION ADD CONSTRAINT JOB_AUTOMATION_PK PRIMARY KEY (JA_CODE, JA_NAME, JA_DATE, JA_COUNT);






SELECT TRUNC(SYSDATE + 1) + 9 / 24 -- 매일
FROM DUAL;
SELECT TRUNC(SYSDATE + 1) + 18 / 24 -- 매일
FROM DUAL;
SELECT TRUNC(LAST_DAY(SYSDATE)) + 10 -- 매달 10일
FROM DUAL;








-- 스케줄러 잡 등록 예제
BEGIN
    DBMS_SCHEDULER.CREATE_JOB (
        JOB_NAME => 'JOB_WORKHISTORY_IN_자동화'
        , START_DATE => TRUNC(SYSDATE + 1) + 9 / 24
        , REPEAT_INTERVAL => 'FREQ=DAILY;INTERVAL=1'
        , END_DATE => NULL
        , JOB_CLASS => 'DEFAULT_JOB_CLASS'
        , JOB_TYPE => 'PLSQL_BLOCK'
        , JOB_ACTION => 'BEGIN PR_TEST(TO_CHAR(SYSDATE,''YYYYMMDDHH24MISS'')); END;'
        , COMMENTS => 'JOB_WORKHISTORY_IN_출근_자동화'
    );
    DBMS_SCHEDULER.ENABLE('JOB_WORKHISTORY_IN_자동화');
END;
 

이렇게 스케줄러를 등록했습니다.
등록한 스케줄러는 다음의 쿼리로 등록된 내역을 확인 할 수 있어요.

SELECT * FROM ALL_SCHEDULER_JOBS WHERE JOB_NAME = 'JOB_WORKHISTORY_IN_자동화';
이렇게 해서 매일 오전 6시에 실행되는 job를 등록했습니다.

지정한 시간에 스케줄러 잡이 정상적으로 실행되었는지는 다음의 쿼리로 확인 할 수 있어요.

SELECT * FROM ALL_SCHEDULER_JOB_LOG;
SELECT * FROM ALL_SCHEDULER_JOB_RUN_DETAILS;

-- 또는
SELECT * FROM USER_SCHEDULER_JOB_LOG;
SELECT * FROM USER_SCHEDULER_JOB_RUN_DETAILS;

-- DETAILS이 붙은 스케줄러 잡 로그 VIEW 테이블은 실행 실패 에러 내용을 조회 할 수 있음






-- 잡(job) 삭제
DBMS_SCHEDULER.DROP_JOB('PR_TEST_JOB');

-- 프로시저 삭제
DROP PROCEDURE JOB_WORKHISTORY;

-- 테이블 삭제
DROP TABLE TBL_TEST;
